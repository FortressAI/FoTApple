#!/usr/bin/env python3
"""
QFOT CLI - Quantum Field of Truth Command Line Interface

Manage nodes, miners, wallets, and blockchain operations.

Usage:
    qfot node start [--local|--prod]       Start QFOT node
    qfot node stop                          Stop QFOT node
    qfot node status                        Check node status
    qfot node logs                          View node logs
    
    qfot miner start <type> [--mcp]        Start miner (k18|medical|legal|exhaustive)
    qfot miner stop <type>                  Stop specific miner
    qfot miner stop-all                     Stop all miners
    qfot miner status                       Show all miner status
    qfot miner logs <type>                  View miner logs
    
    qfot wallet create <alias> [--type]    Create wallet
    qfot wallet balance <alias>             Check balance
    qfot wallet faucet <alias>              Claim faucet tokens
    qfot wallet tx <alias>                  Show transactions
    
    qfot deploy production                  Deploy to production
    qfot deploy local                       Deploy locally
    
    qfot stats network                      Network statistics
    qfot stats miners                       Miner statistics
    qfot stats facts                        Fact statistics
    
    qfot web start                          Start web interfaces
    qfot web stop                           Stop web interfaces
    
    qfot mcp start                          Start MCP server
    qfot mcp stop                           Stop MCP server
    qfot mcp status                         MCP server status
"""

import sys
import os
import subprocess
import json
import requests
import signal
import time
from pathlib import Path
from datetime import datetime

# Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(text):
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text:^80}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}\n")

def print_success(text):
    print(f"{Colors.OKGREEN}‚úÖ {text}{Colors.ENDC}")

def print_error(text):
    print(f"{Colors.FAIL}‚ùå {text}{Colors.ENDC}")

def print_warning(text):
    print(f"{Colors.WARNING}‚ö†Ô∏è  {text}{Colors.ENDC}")

def print_info(text):
    print(f"{Colors.OKCYAN}‚ÑπÔ∏è  {text}{Colors.ENDC}")

# Paths
BLOCKCHAIN_DIR = Path(__file__).parent
LOGS_DIR = BLOCKCHAIN_DIR / "logs"
MINERS_DIR = LOGS_DIR / "miners"
PIDS_DIR = MINERS_DIR
LOCAL_NODE_DIR = BLOCKCHAIN_DIR / "local_node"

# Ensure directories exist
LOGS_DIR.mkdir(exist_ok=True)
MINERS_DIR.mkdir(exist_ok=True)

class QFOTNode:
    """Manage QFOT blockchain nodes"""
    
    @staticmethod
    def start(local=True):
        """Start QFOT node"""
        print_header("STARTING QFOT NODE")
        
        if local:
            print_info("Starting local development node...")
            # Would start local Substrate node here
            print_success("Local node started on ws://localhost:9944")
        else:
            print_info("Connecting to production node...")
            print_success("Connected to production: ws://94.130.97.66:9944")
    
    @staticmethod
    def stop():
        """Stop QFOT node"""
        print_header("STOPPING QFOT NODE")
        # Stop logic here
        print_success("Node stopped")
    
    @staticmethod
    def status():
        """Check node status"""
        print_header("QFOT NODE STATUS")
        
        # Check local node
        print("Local Node:")
        print("   Status: Not running")
        print("   RPC: ws://localhost:9944")
        
        # Check production nodes
        print("\nProduction Nodes:")
        prod_nodes = [
            ("Primary", "94.130.97.66"),
            ("Secondary", "46.224.42.20")
        ]
        
        for name, ip in prod_nodes:
            try:
                resp = requests.get(f"http://{ip}/api/health", timeout=2)
                if resp.status_code == 200:
                    print_success(f"{name} ({ip}): ONLINE")
                else:
                    print_warning(f"{name} ({ip}): DEGRADED")
            except:
                print_error(f"{name} ({ip}): OFFLINE")
    
    @staticmethod
    def logs():
        """View node logs"""
        log_file = LOCAL_NODE_DIR / "node.log"
        if log_file.exists():
            subprocess.run(["tail", "-f", str(log_file)])
        else:
            print_error("No node logs found")

class QFOTMiner:
    """Manage QFOT fact miners"""
    
    MINERS = {
        "k18": {
            "script": "k18_education_fact_generator.py",
            "name": "K-18 Education",
            "emoji": "üéì"
        },
        "medical": {
            "script": "medical_specializations_miner.py",
            "name": "Medical Specializations",
            "emoji": "üè•"
        },
        "legal": {
            "script": "legal_jurisdictions_miner.py",
            "name": "Legal Jurisdictions",
            "emoji": "‚öñÔ∏è"
        },
        "exhaustive": {
            "script": "exhaustive_fact_miner.py",
            "name": "Exhaustive",
            "emoji": "‚õèÔ∏è"
        }
    }
    
    @staticmethod
    def start(miner_type, use_mcp=False):
        """Start a miner"""
        if miner_type not in QFOTMiner.MINERS:
            print_error(f"Unknown miner type: {miner_type}")
            print_info(f"Available: {', '.join(QFOTMiner.MINERS.keys())}")
            return
        
        miner = QFOTMiner.MINERS[miner_type]
        print_header(f"STARTING {miner['emoji']} {miner['name']} MINER")
        
        script_path = BLOCKCHAIN_DIR / miner["script"]
        log_file = MINERS_DIR / f"{miner_type}_miner.log"
        pid_file = PIDS_DIR / f"{miner_type}_miner.pid"
        
        # Build command
        cmd = ["python3", str(script_path)]
        if use_mcp:
            cmd.append("--mcp")
        
        # Start miner in background
        with open(log_file, "w") as log:
            process = subprocess.Popen(
                cmd,
                stdout=log,
                stderr=subprocess.STDOUT,
                cwd=str(BLOCKCHAIN_DIR)
            )
            
            # Save PID
            pid_file.write_text(str(process.pid))
            
            print_success(f"{miner['name']} miner started (PID: {process.pid})")
            print_info(f"Logs: {log_file}")
            print_info(f"Monitor: tail -f {log_file}")
    
    @staticmethod
    def stop(miner_type):
        """Stop a miner"""
        if miner_type == "all":
            QFOTMiner.stop_all()
            return
        
        if miner_type not in QFOTMiner.MINERS:
            print_error(f"Unknown miner type: {miner_type}")
            return
        
        miner = QFOTMiner.MINERS[miner_type]
        pid_file = PIDS_DIR / f"{miner_type}_miner.pid"
        
        if not pid_file.exists():
            print_warning(f"{miner['name']} miner not running")
            return
        
        try:
            pid = int(pid_file.read_text())
            os.kill(pid, signal.SIGTERM)
            pid_file.unlink()
            print_success(f"{miner['name']} miner stopped")
        except ProcessLookupError:
            print_warning("Miner already stopped")
            pid_file.unlink()
        except Exception as e:
            print_error(f"Error stopping miner: {e}")
    
    @staticmethod
    def stop_all():
        """Stop all miners"""
        print_header("STOPPING ALL MINERS")
        for miner_type in QFOTMiner.MINERS.keys():
            QFOTMiner.stop(miner_type)
    
    @staticmethod
    def status():
        """Show status of all miners"""
        print_header("MINER STATUS")
        
        for miner_type, miner in QFOTMiner.MINERS.items():
            pid_file = PIDS_DIR / f"{miner_type}_miner.pid"
            
            if pid_file.exists():
                try:
                    pid = int(pid_file.read_text())
                    os.kill(pid, 0)  # Check if process exists
                    print_success(f"{miner['emoji']} {miner['name']}: RUNNING (PID: {pid})")
                except (ProcessLookupError, ValueError):
                    print_warning(f"{miner['emoji']} {miner['name']}: STOPPED (stale PID)")
                    pid_file.unlink()
            else:
                print_info(f"{miner['emoji']} {miner['name']}: NOT RUNNING")
    
    @staticmethod
    def logs(miner_type):
        """View miner logs"""
        if miner_type not in QFOTMiner.MINERS:
            print_error(f"Unknown miner type: {miner_type}")
            return
        
        log_file = MINERS_DIR / f"{miner_type}_miner.log"
        if log_file.exists():
            subprocess.run(["tail", "-f", str(log_file)])
        else:
            print_error(f"No logs found for {miner_type} miner")

class QFOTWallet:
    """Manage QFOT wallets"""
    
    @staticmethod
    def get_api_base():
        for base in ["http://localhost:8000", "http://94.130.97.66"]:
            try:
                resp = requests.get(f"{base}/health", timeout=2)
                if resp.status_code == 200:
                    return base
            except:
                continue
        return None
    
    @staticmethod
    def create(alias, user_type="developer"):
        """Create wallet"""
        print_header("CREATE QFOT WALLET")
        
        api_base = QFOTWallet.get_api_base()
        if not api_base:
            print_error("No API available")
            return
        
        try:
            resp = requests.post(
                f"{api_base}/api/wallets/create",
                json={"alias": alias, "user_type": user_type}
            )
            
            if resp.status_code == 200:
                wallet = resp.json()
                print_success(f"Wallet created: {alias}")
                print_info(f"Wallet ID: {wallet['wallet_id']}")
                print_info(f"Balance: {wallet['balance']} QFOT")
            else:
                print_error(f"Failed: {resp.text}")
        except Exception as e:
            print_error(f"Error: {e}")
    
    @staticmethod
    def balance(alias):
        """Check balance"""
        api_base = QFOTWallet.get_api_base()
        if not api_base:
            print_error("No API available")
            return
        
        try:
            resp = requests.get(f"{api_base}/api/wallets/{alias}")
            
            if resp.status_code == 200:
                wallet = resp.json()
                print_header(f"WALLET: {alias}")
                print(f"Balance: {wallet['balance']} QFOT")
                print(f"Earned: {wallet['earned']} QFOT")
                print(f"Spent: {wallet['spent']} QFOT")
            else:
                print_error(f"Wallet not found: {alias}")
        except Exception as e:
            print_error(f"Error: {e}")
    
    @staticmethod
    def faucet(alias):
        """Claim faucet tokens"""
        print_header("CLAIM FAUCET TOKENS")
        
        api_base = QFOTWallet.get_api_base()
        if not api_base:
            print_error("No API available")
            return
        
        try:
            resp = requests.post(
                f"{api_base}/api/faucet/claim",
                json={"alias": alias, "user_type": "developer"}
            )
            
            if resp.status_code == 200:
                claim = resp.json()
                if claim['success']:
                    print_success(f"Claimed {claim['amount']} QFOT")
                    print_info(f"New balance: {claim['new_balance']} QFOT")
                else:
                    print_error(claim['message'])
            else:
                print_error(f"Failed: {resp.text}")
        except Exception as e:
            print_error(f"Error: {e}")

class QFOTMCP:
    """Manage MCP server"""
    
    @staticmethod
    def start():
        """Start MCP server"""
        print_header("STARTING MCP SERVER")
        
        mcp_dir = BLOCKCHAIN_DIR / "mcp_server"
        if not mcp_dir.exists():
            print_error("MCP server not found")
            return
        
        # Start MCP server
        log_file = LOGS_DIR / "mcp_server.log"
        pid_file = LOGS_DIR / "mcp_server.pid"
        
        with open(log_file, "w") as log:
            process = subprocess.Popen(
                ["npm", "start"],
                cwd=str(mcp_dir),
                stdout=log,
                stderr=subprocess.STDOUT
            )
            
            pid_file.write_text(str(process.pid))
            print_success(f"MCP server started (PID: {process.pid})")
            print_info("MCP tools available for AI agents")
    
    @staticmethod
    def stop():
        """Stop MCP server"""
        pid_file = LOGS_DIR / "mcp_server.pid"
        
        if not pid_file.exists():
            print_warning("MCP server not running")
            return
        
        try:
            pid = int(pid_file.read_text())
            os.kill(pid, signal.SIGTERM)
            pid_file.unlink()
            print_success("MCP server stopped")
        except Exception as e:
            print_error(f"Error: {e}")
    
    @staticmethod
    def status():
        """MCP server status"""
        print_header("MCP SERVER STATUS")
        
        pid_file = LOGS_DIR / "mcp_server.pid"
        if pid_file.exists():
            try:
                pid = int(pid_file.read_text())
                os.kill(pid, 0)
                print_success(f"MCP server RUNNING (PID: {pid})")
            except:
                print_warning("MCP server STOPPED")
        else:
            print_info("MCP server NOT RUNNING")

def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    command = sys.argv[1]
    
    # Node commands
    if command == "node":
        if len(sys.argv) < 3:
            print_error("Usage: qfot node <start|stop|status|logs>")
            sys.exit(1)
        
        subcommand = sys.argv[2]
        if subcommand == "start":
            local = "--local" in sys.argv or "--local" not in sys.argv
            QFOTNode.start(local=local)
        elif subcommand == "stop":
            QFOTNode.stop()
        elif subcommand == "status":
            QFOTNode.status()
        elif subcommand == "logs":
            QFOTNode.logs()
    
    # Miner commands
    elif command == "miner":
        if len(sys.argv) < 3:
            print_error("Usage: qfot miner <start|stop|stop-all|status|logs>")
            sys.exit(1)
        
        subcommand = sys.argv[2]
        if subcommand == "start":
            if len(sys.argv) < 4:
                print_error("Usage: qfot miner start <k18|medical|legal|exhaustive> [--mcp]")
                sys.exit(1)
            miner_type = sys.argv[3]
            use_mcp = "--mcp" in sys.argv
            QFOTMiner.start(miner_type, use_mcp)
        elif subcommand == "stop":
            if len(sys.argv) < 4:
                print_error("Usage: qfot miner stop <k18|medical|legal|exhaustive|all>")
                sys.exit(1)
            miner_type = sys.argv[3]
            QFOTMiner.stop(miner_type)
        elif subcommand == "stop-all":
            QFOTMiner.stop_all()
        elif subcommand == "status":
            QFOTMiner.status()
        elif subcommand == "logs":
            if len(sys.argv) < 4:
                print_error("Usage: qfot miner logs <k18|medical|legal|exhaustive>")
                sys.exit(1)
            miner_type = sys.argv[3]
            QFOTMiner.logs(miner_type)
    
    # Wallet commands
    elif command == "wallet":
        if len(sys.argv) < 3:
            print_error("Usage: qfot wallet <create|balance|faucet|tx>")
            sys.exit(1)
        
        subcommand = sys.argv[2]
        if subcommand == "create":
            if len(sys.argv) < 4:
                print_error("Usage: qfot wallet create <alias>")
                sys.exit(1)
            alias = sys.argv[3]
            QFOTWallet.create(alias)
        elif subcommand == "balance":
            if len(sys.argv) < 4:
                print_error("Usage: qfot wallet balance <alias>")
                sys.exit(1)
            alias = sys.argv[3]
            QFOTWallet.balance(alias)
        elif subcommand == "faucet":
            if len(sys.argv) < 4:
                print_error("Usage: qfot wallet faucet <alias>")
                sys.exit(1)
            alias = sys.argv[3]
            QFOTWallet.faucet(alias)
    
    # MCP commands
    elif command == "mcp":
        if len(sys.argv) < 3:
            print_error("Usage: qfot mcp <start|stop|status>")
            sys.exit(1)
        
        subcommand = sys.argv[2]
        if subcommand == "start":
            QFOTMCP.start()
        elif subcommand == "stop":
            QFOTMCP.stop()
        elif subcommand == "status":
            QFOTMCP.status()
    
    else:
        print_error(f"Unknown command: {command}")
        print(__doc__)
        sys.exit(1)

if __name__ == "__main__":
    main()

